[{"title":"vue3.0迭代计划（译文）","date":"2019-05-05T08:14:44.379Z","path":"2019/05/05/vue3.0迭代计划/","text":"译自：Plans for the Next Iteration of Vue.js，翻译一遍，好像比起看一遍要记忆更深一点。 上周在vue.js伦敦，我简要介绍了vue下一个主要版本即将发布的内容。这篇文章提供了对该计划的深入概述。 为什么会发布一个major版本？vue 2.0在两年前发布（时间过得真快！）。在这段时间里，vue的核心部分已经进行了5个次要版本的兼容。我们推迟了很多能改进vue的想法，因为他们有可能带来不兼容的改变。与此同时，js生态系统和语言本身也在快速发展。有很多强大的工具可用来增强我们的工作流程，js的很多新特性也可以为vue想要解决的问题提供一些更简单，更有效率，更完善的解决办法。更令人兴奋的是，es2015的支持成为了几乎所有主流浏览器的基准。Vue 3.0旨在利用这些新的语言特性，使Vue核心更小，更快，更强大。 Vue 3.0目前处于原型设计阶段，我们已经实现了一个接近功能奇偶校验的运行时2.x​​。下面列出的许多项目已经实施或确认可行。尚未实施或仍处于勘探阶段的标记为*。 详细内容高级api修改 概要：除render函数API和作用域插槽语法之外的所有内容都将保持不变，或者可以通过兼容性构建使其兼容2.x 这是一个新的major，会有一些突破性的变化。但是，我们很重视向后兼容性，因此我们希望尽快开始传达这些更改。以下是当前计划的公共API更改： template语法将保持99％相同。在作用域槽语法中可能会有一些小的调整，除此之外我们没有计划为模板更改任何其他内容 3.0将原生支持基于类的组件，旨在提供在原生ES2015中使用的API，无需任何转换或stage-x功能。大多数当前选项在基于类的API中具有合理的映射。Stage-x功能（如类字段和装饰器）仍可以选择性地用于增强创作体验。此外，API在设计时考虑了TypeScript类型推断。3.x代码库本身将使用TypeScript编写，并提供改进的TypeScript支持。（也就是说，在应用程序中使用TypeScript仍然是完全可选的。） 通过在内部将对象转换为相应的类，仍将支持2.x基于对象的组件格式。 Mixins仍将受到支持。* 为避免插件安装时全局变更Vue运行时，顶级API可能会有较大的改动。插件将应用并作用于组件树。这样可以更轻松地测试依赖于特定插件的组件，还可以使用不同的插件在同一页面上安装多个Vue应用程序，但使用相同的Vue运行时。* 功能组件可以通过普通函数编写 - 但是，现在需要通过辅助函数显式创建异步组件。 将获得最多更改的部分是render函数中使用的Virtual DOM格式。我们目前正在收集主要库作者的反馈意见，当我们对这些变化更有信心时将分享更多细节。但只要您不严重依赖应用程序中的手写（非JSX）渲染功能，升级应该是一个相当简单的过程。 源码架构 概要：更好的解耦内部模块，TypeScript和更容易贡献的代码库 我们正在从头开始重新编写3.0，以实现更清晰，更易维护的架构，特别是尝试使其更容易做出贡献。我们将一些内部功能分解为单独的包，以便隔离复杂性。例如，观察者模块将成为自己的包，具有自己的公共API和测试。请注意，这不会影响框架级API - 您不必手动导入多个包以使用Vue。相反，最终的Vue包使用这些内部包进行组装。 代码库现在用TypeScript编写。虽然这可能使得TypeScript的熟练程度成为为新代码库做出贡献的先决条件，但我们相信类型信息和IDE支持实际上将使新贡献者更容易做出有意义的贡献。 将观察者和调度程序分离到单独的包中还允许我们轻松地尝试这些部分的替代实现。例如，我们可以使用相同的API实现IE11兼容的观察器实现，或者利用requestIdleCallback在长时间更新期间向浏览器提供的替代调度。* 观察机制 概要：更完整，精确，高效和可调试的反应性跟踪和用于创建可观察的API。 3.0将附带基于proxy的观察器实现，该实现提供具有完整语言覆盖的反应性跟踪。这消除了基于Object.defineProperty的Vue 2当前实现的许多限制： 对象新属性的添加/删除 数组基于索引或length的改动 对Map, Set, WeakMap 和 WeakSet的支持 新observer还具有以下特性： 用于创建可观察对象的公开API。这为中小规模场景提供了轻量级，简单的跨组件状态管理解决方案。 默认懒惰观察。在2.x中，任何被动数据，无论其大小，都会在启动时被观察到。如果您的数据集很大，这可能会导致应用启动时出现明显的开销。在3.x中，只需要观察用于渲染应用程序初始可见内容的数据，更不用说观察本身也要快得多。 更精确的变动通知。例如：在2.x中，使用Vue.set添加新属性将导致依赖于对象的任何观察者重新评估。在3.x中，只会通知依赖于该特定属性的观察者。 不可变的observables：我们可以创建一个值的“不可变”版本，即使在嵌套属性上也可以防止突变，除非系统在内部暂时解锁它。这种机制可用于冻结传递的道具或Vuex状态树以外的突变。 更好的调试功能：我们可以精确地跟踪使用新的renderTracked和renderTriggered挂钩跟踪或触发组件重新渲染的时间和原因： 其他运行时改进 概要：更小，更快， tree-shakable的功能，fragments和portals，自定义renderer API。 更小：新的代码库从一开始就设计为易于使用tree-shaking。现在，按需和树可动态导入内置组件（&lt;transition&gt;，&lt;keep-alive&gt;）和指令运行时助手（v-model）等功能。新运行时的常规大小为&lt;10kb gzip。此外，tree-shaking还允许我们在未来提供更多内置功能，而不会对不使用它们的用户造成负载惩罚。 更快：在初步基准测试中，我们看到全面的性能提升高达100％，包括原始Virtual DOM安装和修补（我们从Inferno学到了很多技巧，最快的Virtual DOM实现），组件实例初始化和数据观察。3.0在您应用程序启动时，花费在js上的时间减少了一半。 Fragments和Portals：尽管尺寸变小了，但3.0内置支持Fragments（返回多个根节点的组件）和Portals（在DOM的另一部分中呈现子树，而不是在组件内部） 改进的插槽机制：所有编译器生成的插槽现在都是函数，并在子组件的渲染调用期间调用。这确保了插槽中的依赖关系被收集为子组件而不是父组件的依赖关系。这意味着：1。当插槽内容发生变化时，只有子组件重新渲染;2.当父组件重新渲染时，如果其插槽内容没有改变，则子组件不必。此更改在组件树级别提供更精确的更改检测，因此更少的无用重新渲染！ 自定义RendererAPI：用于创建自定义渲染器的API将可用，不再需要fork Vue代码库来自定义修改来。这将使像Weex和NativeScript Vue这样的渲染到本机项目更容易与上游更改保持同步。它还可以轻松地为各种其他目的创建自定义渲染器 编译器改进* 概要：tree-shaking友好输出，更多AOT优化，具有更好错误信息和源map支持的parser 在target是具有tree-shaking功能的bundler时，使用可选功能的模板将使用ES模块导入这些功能。未使用的可选功能将从最终捆绑中删除。 由于新的Virtual DOM实现的改进，我们还能够执行更有效的编译时优化，例如静态树提升，静态props提升，运行时的编译器提示以跳过children normalization，VNode创建快速路径等等… 我们计划重写解析器，这可以在模板编译错误中提供位置信息，也可以提供模板源map支持。新的解析器可以作为第三方工具集成的基础，例如eslint-plugin-vue和IDE语言服务。 IE11支持* 概要：它将受到支持，但会在一个分开的包中，它有着和Vue 2.x相同的响应限制。 新代码库目前仅针对常青浏览器，并假设他们都支持ES2015。但是，我们知道很多用户在可预见的未来仍然需要支持IE11。对于IE11，大多数使用的ES2015功能都可以进行转换/填充，但Proxy除外。我们的计划是使用相同的API实现另一个观察者，但使用旧的ES5 Object.defineProperty API。将使用此观察器实现单独的Vue 3.x版本。此构建将受到Vue 2.x的相同更改检测警告的影响，因此与3.x的“现代”构建不完全兼容。我们知道这给库的作者带来了一些不便，因为他们需要了解两个不同版本的兼容性，但是当我们将要这么做时，我们确保为此提供明确的指导。 如何达成首先，虽然我们今天宣布，但我们还没有明确的时间表。我们目前所知道的是我们将采取的步骤： 1.runtime原型的内部反馈这是我们现在所处的阶段。目前，我们已经有一个工作的runtime原型，包括新的观察者，Virtual DOM和组件实现。我们邀请了一组有影响力的社区项目的作者为内部变化提供反馈，并希望在继续前进之前确保他们对变化感到满意。我们希望确保生态系统中的重要库在我们发布3.0的同时准备就绪，以便依赖这些项目的用户可以轻松升级。 2.通过RFC的公众反馈对于每次重大变更，一旦我们对新设计有了一定程度的信心，我们将打开一个专门的RFC问题，其中包括： 变更范围; 变革背后的推理：我们获得了什么，以及正在进行哪些权衡; 升级路径：是否可以通过可插拔的兼容层或重构以完全向后兼容的方式引入？ 我们期待来自社区的更广泛的公众反馈，以帮助我们巩固这些想法。 3.在2.x和2.x-next中引入兼容功能我们不会忘记2.x！事实上，我们计划使用2.x逐步使用户适应新的变化。我们将通过opt-in适配器逐步将确认的API更改引入2.x。2.x-next将允许用户尝试新的基于Proxy的观察器。2.x中的最后一个次要版本将成为LTS，并在3.0发布后继续接受18个月的错误和安全修复。 4.alpha阶段接下来，我们将完成3.0的编译器和服务器端渲染部分并开始制作alpha版本。这些主要用于小型应用中的稳定性测试。 5. Beta阶段在Beta阶段，我们的主要目标是更新支持库和工具，如Vue Router，Vuex，Vue CLI，Vue DevTools，并确保它们与新核心一起顺利运行。我们还将与社区的主要库作者合作，帮助他们为3.0做好准备。 6. RC阶段一旦我们认为API和代码库稳定，我们将进入带有API冻结的RC阶段。在此阶段，我们还将开发“compat build”：3.0版本，包含2.x API的兼容性层。此版本还将附带一个开关，您可以打开该开关以在应用程序中为2.x API使用情况，并发出弃用警告。“compat build”可用作将应用程序升级到3.0的指南。 7. IE11构建最终版本之前的最后一个任务是IE11兼容性构建，如上所述。 8.最终发布老实说，我们不知道这将在何时发生，但很可能在2019年。我们更关心的是运送稳定的东西而不是特定的日期。有很多工作要做，但我们仍未将到来的欢呼！","tags":[]},{"title":"typescript记录之Handbook(Basic Types、Interfaces、Classes)","date":"2019-04-28T09:18:17.874Z","path":"2019/04/28/typescript/","text":"本篇文章主要用于记录之用，从头到尾读一下 ts 文档，并记录下其中需要学习的东西，毕竟里面有许多是不需要看的，像一些基本类型定义、或是 es6 已经很常用的一些语法，记录这些，大概也能对进一步学习 ts 有个较好的作用，而不是每次翻开文档，从头看个几页，下次又从头开始，大致从 handbook 和 what new 两部分开始，因考虑到内容较长，分多篇 HandbookBasic Typesnever 类型never 类型代表永不会发生的类型，大多用于表示函数返回值，如 1234567891011121314// Function returning never must have unreachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;// Function returning never must have unreachable end pointfunction infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; 类型断言某些时候，你可能比 ts 更了解某个类型的值，这个时候可以使用类型断言，类型断言有两种方式 12345let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length;let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 因为 jsx 的普遍使用，第二种方式更为推荐 InterfacesIndexable Types索引类型有一个索引签名用来描述，我们用什么类型对这个对象索引，以及使用索引时返回的内容类型，例如： 123interface StringArray &#123; [index: number]: string;&#125; 上述是用来表示一个用数字为索引，返回值为 string 的对象，即 string[],索引签名只有两种类型，string/number，但是这两种索引类型是不能共用的，因为 number 类型和 string 共用时，只能使用对象来表示，number 会被转为 string 类对接口的实现使用 implements 关键字可以表示类对接口的实现 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125; 一个 class 有两种类型，一种是静态端，一种是实例端，construct 函数式属于静态端的，所以下面内容会报错 12345678interface ClockConstructor &#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 一个简单的办法是 1234567891011121314interface ClockConstructor &#123; new (hour: number, minute: number);&#125;interface ClockInterface &#123; tick();&#125;const Clock: ClockConstructor = class Clock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125; 接口可以继承多个接口 12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; Hybrid Types可以描述一个既是函数又是对象的对象 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; Interfaces Extending Classes接口继承一个 class 的时候，会继承它的所有属性，包含 private 和 protected 的属性。这意味着如果你去实现一个继承了含 private 和 protected 属性的 class 的接口，只能通过这个 class 或者它的子类。这在你要使用一些有固定属性的子类时比较有用，这些子类除了继承自同一个父类外，不用有其他的联系。 1234567891011121314151617class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123; &#125;&#125;// Error: Property 'state' is missing in type 'Image'.class Image implements SelectableControl &#123; private state: any; select() &#123; &#125;&#125; 上例中，Button 的校验是通过的，因为它的 state 属性继承自 Control，而 Image 是不通过的，因为它的 state 属性与 SelectableControl 要求的不是同一来源，在属性为 private 和 protected 时，来源的校验是必须的。 Classes类的定义大多基于 es 标准，在这里不过多赘述，下面仅记录一些不常见或是 ts 特有的语法 Parameter properties参数属性是一种并不那么直观的语法糖，适用于 public, protected,private,readonly如下两种写法是等同的 123456789101112class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) &#123; this.name = theName; &#125;&#125;class Octopus &#123; readonly numberOfLegs: number = 8; constructor(readonly name: string) &#123; &#125;&#125; Abstract Classes抽象类是可以从中派生其他类的基类。它们可能无法直接实例化。与接口不同，抽象类可以包含其部分成员的实现。abstract 关键字用于定义抽象类以及抽象类中的抽象方法。抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法语法类似。两者都定义方法的签名而不包括方法体。但是，抽象方法必须包含 abstract 关键字，并且可以选择包含访问修饰符。 123456789101112131415161718192021222324252627282930313233abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log(\"Department name: \" + this.name); &#125; abstract printMeeting(): void; // must be implemented in derived classes&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super(\"Accounting and Auditing\"); // constructors in derived classes must call super() &#125; printMeeting(): void &#123; console.log(\"The Accounting Department meets each Monday at 10am.\"); &#125; generateReports(): void &#123; console.log(\"Generating accounting reports...\"); &#125;&#125;let department: Department; // ok to create a reference to an abstract type,其实Department在此相当于一个interface，需要赋值department能implements Department的类，故Department的子类也可以，甚至其他属性一样的类department = new Department(); // error: cannot create an instance of an abstract classdepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclassdepartment.printName();department.printMeeting();department.generateReports(); // error: method doesn't exist on declared abstract type Advanced Techniques当我们在 ts 中声明 class 的时候，它做了两个声明，第一个是 class 的实例类型 12345678910111213class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return \"Hello, \" + this.greeting; &#125;&#125;let greeter: Greeter;greeter = new Greeter(\"world\");console.log(greeter.greet()); 像上述代码一样，let greeter: Greeter;，这里面的Greeter代表着类的实例类型。对于来自其他面向对象语言的程序员来说，这几乎是第二天性。第二个是创造了一个构造函数。即下面这段代码 12345678910111213let Greeter = (function() &#123; function Greeter(message) &#123; this.greeting = message; &#125; Greeter.prototype.greet = function() &#123; return \"Hello, \" + this.greeting; &#125;; return Greeter;&#125;)();let greeter;greeter = new Greeter(\"world\");console.log(greeter.greet()); let Greeter即是在声明构造函数，class 的另一种说法就是它包含静态端和实例端 123456789101112131415161718192021class Greeter &#123; static standardGreeting = \"Hello, there\"; greeting: string; greet() &#123; if (this.greeting) &#123; return \"Hello, \" + this.greeting; &#125; else &#123; return Greeter.standardGreeting; &#125; &#125;&#125;let greeter1: Greeter;greeter1 = new Greeter();console.log(greeter1.greet()); // Hello, therelet greeterMaker: typeof Greeter = Greeter;greeterMaker.standardGreeting = \"Hey there!\";let greeter2: Greeter = new greeterMaker();console.log(greeter2.greet()); // Hey there! 在上面的例子中，greeterMaker这个变量即是 class 自身，或者说构造函数。我们使用typeof Greeter来获取 class 自身而不是它的实例，值得注意的是，greeterMaker 这个变量被赋值是按引用传递，而不是按值，所以它改变了整个 Greeter，接下来使用 Greeter 创建的实例都将 Hey there! Using a class as an interface和上面说的一样，类的声明创造了两个东西，一是代表着类的实例的类型定义，一是 constructor function。因为类创造了类型定义，所以你可以把它当做接口来用 12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125;;","tags":[]},{"title":"web前端演进史简述","date":"2018-12-15T13:47:17.660Z","path":"2018/12/15/web前端演进史简述/","text":"一直想维护自己的博客，但是都未下手，拖延的毛病总是改不了，古语有云，以史为镜可以知兴替，第一篇就以前端的历史讲起吧，由简入繁 本文主要从三个方面说起1.为什么是javascript在web中使用2.web前端关键节点3.前端开发趋势 一、为什么是javascript在web中使用在浏览器刚刚兴起的时候，网速很慢，上网的费用也很贵，但是当时有这样一种场景。如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。 那一年，正逢 Sun 公司的 Java 语言问世，市场推广活动非常成功。Netscape 公司决定与 Sun 公司合作，浏览器支持嵌入 Java 小程序（后来称为 Java applet）。但是，浏览器脚本语言是否就选用 Java，则存在争论。后来，还是决定不使用 Java，因为网页小程序不需要 Java 这么“重”的语法。但是，同时也决定脚本语言的语法要接近 Java，并且可以支持 Java 程序。这些设想直接排除了使用现存语言，比如 Perl、Python 和 TCL。 1995年5月，Brendan Eich 用了10天时间，设计完成了javascript的第一版 基本语法：借鉴c和java数据结构：借鉴java，将值分为原始值和对象函数：借鉴scheme，将函数作为一等公民原型继承：借鉴self正则：借鉴perl字符串和数组处理：借鉴python 为了保持简单，这种脚本语言缺少一些关键的功能，比如块级作用域、模块、子类型（subtyping）等等，但是可以利用现有功能找出解决办法。这种功能的不足，直接导致了后来 JavaScript 的一个显著特点：对于其他语言，你需要学习语言的各种功能，而对于 JavaScript，你常常需要学习各种解决问题的模式。而且由于来源多样，从一开始就注定，JavaScript 的编程风格是函数式编程和面向对象编程的一种混合体。 “the part that is good is not original, and the part that is original is not good” –Samual johnson 二、web前端关键节点1996年11月，网景正式向ECMA（欧洲计算机制造商协会）提交语言标准。1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规ECMA-262。JavaScript成为了ECMAScript最著名的实现之一 标准的出现，是一门语言赖以成长下去的基础，可参考现在的各大厂商小程序。当然，这对某个时期的开发者而言，也未必幸福，如兼容ie。。和 ECMAScript 有关的不止是262，ECMA 402 则是制定一些基于 ECMAScript 5 或者之后版本的一些国际化 API 标准。ECMA 404 是 JSON 规范。ECMA 414 则规定了哪些规范是和 ECMAScript 有关的。还有一些其他的版本 1998年前后，Outlook Web Access小组写成了允许客户端脚本发送HTTP请求（XMLHTTP）的第一个组件。该组件原属于微软Exchange Server，并且迅速地成为了Internet Explorer 4.0[2]的一部分1999年，IE 5部署了 XMLHttpRequest 接口，允许 JavaScript 发出 HTTP 请求2004年4月1日，Google Gmail的发布 gmail让众前端开发者(当时估计就没有几个专职的前端开发人员)认识到，原来前端可以做如此吊的应用，ajax原来可以这样玩。2004年，Google 公司发布了 Gmail，促成了互联网应用程序（Web Application）这个概念的诞生。由于 Gmail 是在4月1日发布的，很多人起初以为这只是一个玩笑。也正是2004年之后，国际上开始出现前端开发工程师 2006年8月26日，jquery第一个稳定版本发布 jQuery 为操作网页 DOM 结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让 JavaScript 语言的应用难度大大降低，推动了这种语言的流行。 2008年9月2日。chrome发布了第一个版本 chrome的发布伴随着v8的到来，如果不是它，node也就可能不会出现，对前端而言，可能是不可想象的 2007年，Webkit 引擎在 iPhone 手机中得到部署。它最初基于 KDE 项目，2003年苹果公司首先采用，2005年开源。这标志着 JavaScript 语言开始能在手机中使用了，意味着有可能写出在桌面电脑和手机中都能使用的程序。2009年，PhoneGap 项目诞生，它将 HTML5 和 JavaScript 引入移动设备的应用程序开发，主要针对 iOS 和 Android 平台，使得 JavaScript 可以用于跨平台的应用程序开发。2009年11月8日，Dahl在欧洲JSConf大会上展示了Node.js项目 按理来说，node是js服务端进军的可能，而下一个则是手机的发展，并没什么联系，其实则不然一方面是node的出现，让前端脱离后端开发成为可能，而另一方面，则是智能手机的兴起，导致了业内对前后端分离开发的追求也正是2010年前后，国内开始有了真正意义上的web前端工程师 2009年，AngularJS诞生2010年10月13号，backbone发布了第一个版本2013年5月React在JSConf US开源2014年2月vue发布 三、前端开发趋势建议大家去看阿里技术出版的《不止代码》一书，当然这本书也是一种趋势的思考，并不能代表全部，真正的路在脚下，送大家一句话“一个人几乎可以在任何他怀有无限热忱的事情上成功” -查尔斯·史考伯","tags":[]},{"title":"Hello World","date":"2018-08-08T05:53:13.000Z","path":"2018/08/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]