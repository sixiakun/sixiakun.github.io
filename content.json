[{"title":"typescript记录之Handbook(Basic Types、Interfaces、Classes)","date":"2019-04-28T09:18:17.874Z","path":"2019/04/28/typescript/","text":"本篇文章主要用于记录之用，从头到尾读一下 ts 文档，并记录下其中需要学习的东西，毕竟里面有许多是不需要看的，像一些基本类型定义、或是 es6 已经很常用的一些语法，记录这些，大概也能对进一步学习 ts 有个较好的作用，而不是每次翻开文档，从头看个几页，下次又从头开始，大致从 handbook 和 what new 两部分开始，因考虑到内容较长，分多篇 HandbookBasic Typesnever 类型never 类型代表永不会发生的类型，大多用于表示函数返回值，如 1234567891011121314// Function returning never must have unreachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;// Function returning never must have unreachable end pointfunction infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; 类型断言某些时候，你可能比 ts 更了解某个类型的值，这个时候可以使用类型断言，类型断言有两种方式 12345let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length;let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 因为 jsx 的普遍使用，第二种方式更为推荐 InterfacesIndexable Types索引类型有一个索引签名用来描述，我们用什么类型对这个对象索引，以及使用索引时返回的内容类型，例如： 123interface StringArray &#123; [index: number]: string;&#125; 上述是用来表示一个用数字为索引，返回值为 string 的对象，即 string[],索引签名只有两种类型，string/number，但是这两种索引类型是不能共用的，因为 number 类型和 string 共用时，只能使用对象来表示，number 会被转为 string 类对接口的实现使用 implements 关键字可以表示类对接口的实现 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125; 一个 class 有两种类型，一种是静态端，一种是实例端，construct 函数式属于静态端的，所以下面内容会报错 12345678interface ClockConstructor &#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 一个简单的办法是 1234567891011121314interface ClockConstructor &#123; new (hour: number, minute: number);&#125;interface ClockInterface &#123; tick();&#125;const Clock: ClockConstructor = class Clock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125; 接口可以继承多个接口 12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; Hybrid Types可以描述一个既是函数又是对象的对象 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; Interfaces Extending Classes接口继承一个 class 的时候，会继承它的所有属性，包含 private 和 protected 的属性。这意味着如果你去实现一个继承了含 private 和 protected 属性的 class 的接口，只能通过这个 class 或者它的子类。这在你要使用一些有固定属性的子类时比较有用，这些子类除了继承自同一个父类外，不用有其他的联系。 1234567891011121314151617class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123; &#125;&#125;// Error: Property 'state' is missing in type 'Image'.class Image implements SelectableControl &#123; private state: any; select() &#123; &#125;&#125; 上例中，Button 的校验是通过的，因为它的 state 属性继承自 Control，而 Image 是不通过的，因为它的 state 属性与 SelectableControl 要求的不是同一来源，在属性为 private 和 protected 时，来源的校验是必须的。 Classes类的定义大多基于 es 标准，在这里不过多赘述，下面仅记录一些不常见或是 ts 特有的语法 Parameter properties参数属性是一种并不那么直观的语法糖，适用于 public, protected,private,readonly如下两种写法是等同的 123456789101112class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) &#123; this.name = theName; &#125;&#125;class Octopus &#123; readonly numberOfLegs: number = 8; constructor(readonly name: string) &#123; &#125;&#125; Abstract Classes抽象类是可以从中派生其他类的基类。它们可能无法直接实例化。与接口不同，抽象类可以包含其部分成员的实现。abstract 关键字用于定义抽象类以及抽象类中的抽象方法。抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法语法类似。两者都定义方法的签名而不包括方法体。但是，抽象方法必须包含 abstract 关键字，并且可以选择包含访问修饰符。 123456789101112131415161718192021222324252627282930313233abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log(\"Department name: \" + this.name); &#125; abstract printMeeting(): void; // must be implemented in derived classes&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super(\"Accounting and Auditing\"); // constructors in derived classes must call super() &#125; printMeeting(): void &#123; console.log(\"The Accounting Department meets each Monday at 10am.\"); &#125; generateReports(): void &#123; console.log(\"Generating accounting reports...\"); &#125;&#125;let department: Department; // ok to create a reference to an abstract type,其实Department在此相当于一个interface，需要赋值department能implements Department的类，故Department的子类也可以，甚至其他属性一样的类department = new Department(); // error: cannot create an instance of an abstract classdepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclassdepartment.printName();department.printMeeting();department.generateReports(); // error: method doesn't exist on declared abstract type Advanced Techniques当我们在 ts 中声明 class 的时候，它做了两个声明，第一个是 class 的实例类型 12345678910111213class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return \"Hello, \" + this.greeting; &#125;&#125;let greeter: Greeter;greeter = new Greeter(\"world\");console.log(greeter.greet()); 像上述代码一样，let greeter: Greeter;，这里面的Greeter代表着类的实例类型。对于来自其他面向对象语言的程序员来说，这几乎是第二天性。第二个是创造了一个构造函数。即下面这段代码 12345678910111213let Greeter = (function() &#123; function Greeter(message) &#123; this.greeting = message; &#125; Greeter.prototype.greet = function() &#123; return \"Hello, \" + this.greeting; &#125;; return Greeter;&#125;)();let greeter;greeter = new Greeter(\"world\");console.log(greeter.greet()); let Greeter即是在声明构造函数，class 的另一种说法就是它包含静态端和实例端 123456789101112131415161718192021class Greeter &#123; static standardGreeting = \"Hello, there\"; greeting: string; greet() &#123; if (this.greeting) &#123; return \"Hello, \" + this.greeting; &#125; else &#123; return Greeter.standardGreeting; &#125; &#125;&#125;let greeter1: Greeter;greeter1 = new Greeter();console.log(greeter1.greet()); // Hello, therelet greeterMaker: typeof Greeter = Greeter;greeterMaker.standardGreeting = \"Hey there!\";let greeter2: Greeter = new greeterMaker();console.log(greeter2.greet()); // Hey there! 在上面的例子中，greeterMaker这个变量即是 class 自身，或者说构造函数。我们使用typeof Greeter来获取 class 自身而不是它的实例，值得注意的是，greeterMaker 这个变量被赋值是按引用传递，而不是按值，所以它改变了整个 Greeter，接下来使用 Greeter 创建的实例都将 Hey there! Using a class as an interface和上面说的一样，类的声明创造了两个东西，一是代表着类的实例的类型定义，一是 constructor function。因为类创造了类型定义，所以你可以把它当做接口来用 12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125;;","tags":[]},{"title":"web前端演进史简述","date":"2018-12-15T13:47:17.660Z","path":"2018/12/15/web前端演进史简述/","text":"一直想维护自己的博客，但是都未下手，拖延的毛病总是改不了，古语有云，以史为镜可以知兴替，第一篇就以前端的历史讲起吧，由简入繁 本文主要从三个方面说起1.为什么是javascript在web中使用2.web前端关键节点3.前端开发趋势 一、为什么是javascript在web中使用在浏览器刚刚兴起的时候，网速很慢，上网的费用也很贵，但是当时有这样一种场景。如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。 那一年，正逢 Sun 公司的 Java 语言问世，市场推广活动非常成功。Netscape 公司决定与 Sun 公司合作，浏览器支持嵌入 Java 小程序（后来称为 Java applet）。但是，浏览器脚本语言是否就选用 Java，则存在争论。后来，还是决定不使用 Java，因为网页小程序不需要 Java 这么“重”的语法。但是，同时也决定脚本语言的语法要接近 Java，并且可以支持 Java 程序。这些设想直接排除了使用现存语言，比如 Perl、Python 和 TCL。 1995年5月，Brendan Eich 用了10天时间，设计完成了javascript的第一版 基本语法：借鉴c和java数据结构：借鉴java，将值分为原始值和对象函数：借鉴scheme，将函数作为一等公民原型继承：借鉴self正则：借鉴perl字符串和数组处理：借鉴python 为了保持简单，这种脚本语言缺少一些关键的功能，比如块级作用域、模块、子类型（subtyping）等等，但是可以利用现有功能找出解决办法。这种功能的不足，直接导致了后来 JavaScript 的一个显著特点：对于其他语言，你需要学习语言的各种功能，而对于 JavaScript，你常常需要学习各种解决问题的模式。而且由于来源多样，从一开始就注定，JavaScript 的编程风格是函数式编程和面向对象编程的一种混合体。 “the part that is good is not original, and the part that is original is not good” –Samual johnson 二、web前端关键节点1996年11月，网景正式向ECMA（欧洲计算机制造商协会）提交语言标准。1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规ECMA-262。JavaScript成为了ECMAScript最著名的实现之一 标准的出现，是一门语言赖以成长下去的基础，可参考现在的各大厂商小程序。当然，这对某个时期的开发者而言，也未必幸福，如兼容ie。。和 ECMAScript 有关的不止是262，ECMA 402 则是制定一些基于 ECMAScript 5 或者之后版本的一些国际化 API 标准。ECMA 404 是 JSON 规范。ECMA 414 则规定了哪些规范是和 ECMAScript 有关的。还有一些其他的版本 1998年前后，Outlook Web Access小组写成了允许客户端脚本发送HTTP请求（XMLHTTP）的第一个组件。该组件原属于微软Exchange Server，并且迅速地成为了Internet Explorer 4.0[2]的一部分1999年，IE 5部署了 XMLHttpRequest 接口，允许 JavaScript 发出 HTTP 请求2004年4月1日，Google Gmail的发布 gmail让众前端开发者(当时估计就没有几个专职的前端开发人员)认识到，原来前端可以做如此吊的应用，ajax原来可以这样玩。2004年，Google 公司发布了 Gmail，促成了互联网应用程序（Web Application）这个概念的诞生。由于 Gmail 是在4月1日发布的，很多人起初以为这只是一个玩笑。也正是2004年之后，国际上开始出现前端开发工程师 2006年8月26日，jquery第一个稳定版本发布 jQuery 为操作网页 DOM 结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让 JavaScript 语言的应用难度大大降低，推动了这种语言的流行。 2008年9月2日。chrome发布了第一个版本 chrome的发布伴随着v8的到来，如果不是它，node也就可能不会出现，对前端而言，可能是不可想象的 2007年，Webkit 引擎在 iPhone 手机中得到部署。它最初基于 KDE 项目，2003年苹果公司首先采用，2005年开源。这标志着 JavaScript 语言开始能在手机中使用了，意味着有可能写出在桌面电脑和手机中都能使用的程序。2009年，PhoneGap 项目诞生，它将 HTML5 和 JavaScript 引入移动设备的应用程序开发，主要针对 iOS 和 Android 平台，使得 JavaScript 可以用于跨平台的应用程序开发。2009年11月8日，Dahl在欧洲JSConf大会上展示了Node.js项目 按理来说，node是js服务端进军的可能，而下一个则是手机的发展，并没什么联系，其实则不然一方面是node的出现，让前端脱离后端开发成为可能，而另一方面，则是智能手机的兴起，导致了业内对前后端分离开发的追求也正是2010年前后，国内开始有了真正意义上的web前端工程师 2009年，AngularJS诞生2010年10月13号，backbone发布了第一个版本2013年5月React在JSConf US开源2014年2月vue发布 三、前端开发趋势建议大家去看阿里技术出版的《不止代码》一书，当然这本书也是一种趋势的思考，并不能代表全部，真正的路在脚下，送大家一句话“一个人几乎可以在任何他怀有无限热忱的事情上成功” -查尔斯·史考伯","tags":[]},{"title":"Hello World","date":"2018-08-08T05:53:13.000Z","path":"2018/08/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]